== Form handling / Validation ==

Add validations and form handling.

	event({submit, ...}, Context).
	
Result is javascript, might be redirect javascript.

Validation:
	- attach validations to data of the to be posted element
	- sign with nonce and md5
	- name="bla" add to the post:  "zp_v=bla:email:nonce:aa1b8db21157fae46b72e8731f4023da"

  wf:wire(continueButton, nameTextBox, #validate { validators=[
    #is_required { text="Required." },
    #custom { text="Must start with 'Rusty'.", tag=some_tag, function=fun custom_validator/2 }
  ]}),

becomes:

	<input type="text" name="email" id="bla" value="" />
	{% @validate id="bla"
		type={presence}
		type={email}
		type={not_in_use delegate="xxx"}
	%}

When you don't supply the delegate then either:
- there is a validator module with the name validator_xxxx (where xxxx = validation type)
- there is a validator(some_extra_validate, ..) in the resource

You can access:

	zp_context:get_q()
	zp_context:get_q_validated()
	
Javascript needed:

	add-some-validation(#bla),
	$(#bla).data("zp_validation", "pickled-postback-data");

TODO:
	- add live validation refs in javascript  - done.
	- add onsubmit handler - done.
	- add onsubmit handler after possible form insertion - done.
	- add pickled info per field in the data - done.
	- collect all pickled data on submit - done.
	- collect form fields on submit - done.
	- send ajax with form to postback (either generic "form" or postback wired to form) - done.
	- in postback handler: 
		- catch form submit - done.
		- check all pickled validation handlers -done.
			- postback the invalid fields + error messages - done.
		- call event(submit, ...) of resource (or delegate - as wired to the form) - done.
		- add javascript zp_validation_error(Id, Error) - done.
	- add more erlang validations - done.
	- add redirect action - done.


== Generate/reference automatic ids in template ==

	<a id="{{ #name }}" />  {% button target=#name %}

	Prefix the id name with an unique id generated in each call to a template include.
	Check how the custom_tags are handled.

TODO:
	- Add '#' token to erlydtl scanner - done.
	- Add parse rules to erlydtl grammar - done.
	- Call zp_ids:id() at the start of a compiled template - done.
	- add handling of autoids to the erlydtl compiler - done.

== Add @include scomp with semantics like Smarty include ==

	{% @include file="template.tpl" depend="" maxage=100 var="value" %}

Will add its arguments to a local args context.
Can cache the result (using depend and maxage).
Will have its own autoids.

TODO:
	- add include scomp - done.
	- change parse rules, 'include' is a reserved keyword - done.
	- test basic zp_scomp caching - done.

== Redo the context vars - should not be in context to prevent duplicating on message passing ==

Possible solutions:

	- Let the template server return the template and evaluate the template in the request thread (do not pass context around) - done.

Will need some context vars for lookup of @include variables (which is ok).


== Check & cleanup URL mappings, add a name to the patterns - add {% url %} ==

URL configuration, extracts the config for webmachine but also makes it accessible for {% url %}

[
{lib,       ["lib",'*'],   resource_file_readonly,     [ {root,["priv/lib", "default/lib"]} ]},
{postback,  ["postback"],  resource_postback,          []},
{comet,     ["comet"],     resource_comet,             []},
{none,      ["hello"],     resource_helloworld,        []},
{home,      [],            resource_helloworld,        []}
].


Dispatcher:
	- some hardcoded dispatch rules (lib, postback, comet) - done.
	- add include of dispatch files in priv/default - done.
	- scan resources for dispatch/0 export - done.
	- add {% url %} tag - done.
	- initialize webmachine_dispatch on boot - done.


== Check performance of MySQL / PostgreSQL drivers ==

Benchmark ErlyDB and AMNESIA.
When too slow, use the erlang mnesia db.
Depends on prepared queries - needed for performance and security!

Check PostgreSQL abstraction of ErlyDB - can we user prepared queries?


== Inline Templates ==

Make it possible to translate inline templates, i.e. not from a file.

== Depcache ==

Make a depcache server, now the scomp server uses its own simple cache.
It is better to make one with dependencies, so that the scomps can give MaxAge _and_ dependencies

TODO:
	- add depcache server - done.
	- use depcache server from the zp_scomp server - done.
	- background thread for cleaning up the cache - done.
	- mechanism for flushing entries when the cache fills up - done.

== User support ==

Need support for users.  

One user can have:
	- multiple sessions, with each multiple pages
	- leaves an unique id on a user agent (different per ua - store in database)
	- has unprotected info (nickname, shopping cart)
	- has private info (real name, address, e-mail)
	- is_anonymous flag

When an anonymous user logs on then the data of the anonymous user gets merged into the data of the user.
For this we need to have a merge strategy per variable - maybe put it in the varname?
Strategies per user variable:
	- merge_bag
	- merge_set
	- replace_userdata
	- keep_userdata (default)
	- transient (will not be stored in db)
 
User:define_var(Name, Attrs)

Let modules 'hook' into the user merging / startup routines and solve the variables problem in that way?

User has three property tables (which are reflected in the user process state):
	1. Public (just user cookie is enough)
	2. Protected (must have an autologon, or authenticated)
	3. Private (must have recently authenticated < 30 minutes)

Timestamps on user/person:
	1. Created
	2. Last Visit
	3. Last Authenticated (only in user process)

States of user/person:
	1. Anonymous (expiry date - when do we delete this person)
	2. User (which does not assume verified - just that this is a known user)

Cookie on user-agent:
	1. zpuid - per user agent different
	2. in database coupled
		- coupled with person info
		- last visit timestamp
		- expiry timestamp
		- autologon check, as a expiry timestamp

Flow:

	- On first visit:
		1. Create new user, flag as anonymous user
		2. Add cookie to user, set cookie "zpuid" - valid for 10 years or so - done.
		3. Name of user is empty, no details known except for last visit
		4. Set autologon of cookie to false - an anonymous user can't logon
	- On next visit: - done.
		1. Grab user from db, using zpuid cookie
		2. If no such user -> handle as first visit - done.
		3. Set 'last visit' of user to now()
		4. If autologon status set, mark user in session as logged on (protected stuff is visible)
 
	- On user creation:
		1. Create new user
		2. Send user an e-mail with account details
		3. Log on as the new user (see below)
	- On user logon:
		1. Find user record with username/password (or openid)
		2. Set autologon status of zpuid cookie to checkbox value
		3. If current user is anonymous -> Copy/merge public information over to new user
		4. Change zpsid and zpuid (safety measure)
	- On user logoff:
		1. Set user process state to 'public' (locking protected and private properties)


== Scomps - code change ==

Catch code changes for the scomps so that they can be re-initialised.
	- Ask question about this on erlang-questions group

== Templates - production switch ==

Options to disable the modification checks during production.

== Templates - custom_tags ==

Test & check include paths for the custom_tags

== Google chart ==

Check code, adapt calling interface to something that will work with our template system.

== LOG ==

Add rotating logger to the webmachine logger

== Webmachine / MochiWeb ==

Integrate webmachine and mochiweb in our source tree, check makefiles.

== Library file serving: speedup with file cache and gzip ==

	- Put a file cache into the depcache - done.
	- Serve js and css with gzip

== Add application generation script ==

Like mochiweb and webmachine.  For this we will need to change the lookup paths for tpls etc.
This will implement the appliction specific parts and the uri dispatch rules in a more simple way.
